#ifndef COF_PRINTER
#define COF_PRINTER

#include "Version.h"
#include "Logger.h"
#include "Util.h"
#include "SearchCriteria.h"
#include "OffsetFinder.h"

#include <unordered_map>
#include <sstream>
#include <string>
#include <fstream>
#include <vector>
#include <optional>
#include <algorithm>
#include <cmath>

namespace COF
{
  // After finding our stuff, we print it (to file etc).
  // Centralized printer logic is defined here.
  namespace Printer
  {
    using namespace SearchCriteria;

    namespace Config
    {
      struct Head
      {
        bool ShowGeneratedByMessage = false;

        std::string GeneratedByMessage =
          Util::String::Format("Generated by %s %s", COF_NAME, COF_VERSION);
        std::string UserNote;

        bool ShowProfile = false;
        bool ShowBinaryVersion = true;
        bool ShowDateGenerated = true;
      };

      namespace Section
      {
        namespace Header
        {
          enum class FrameStyle
          {
            None,
            Borderless,
            BorderBox,
            BorderUp,
            BorderDown
          };

          enum class FrameContentAlignment
          {
            Left,
            Center,
            Right
          };

          inline std::unordered_map<std::string, FrameStyle> FrameStyles =
          {
            { "Borderless", FrameStyle::Borderless },
            { "BorderBox", FrameStyle::BorderBox },
            { "BorderUp", FrameStyle::BorderUp },
            { "BorderDown", FrameStyle::BorderDown }
          };

          inline std::unordered_map<std::string, FrameContentAlignment> FrameContentAlignments =
          {
            { "Left", FrameContentAlignment::Left },
            { "Center", FrameContentAlignment::Center },
            { "Right", FrameContentAlignment::Right }
          };

          struct Frame
          {
            FrameStyle Style = FrameStyle::BorderBox;
            FrameContentAlignment AlignContent = FrameContentAlignment::Left;

            std::optional<char> BackgroundChar;
            char BorderChar = '-';
            std::size_t BorderWidth = 80;
            std::size_t Padding = 0;
          };
        } // !namespace Header

        namespace CodeFunction
        {
          enum class ID
          {
            STR,
            VAR
          };

          inline std::unordered_map<std::string, ID> IDs =
          {
            { "STR", ID::STR },
            { "VAR", ID::VAR }
          };

          namespace Args
          {
            // Print-function arguments:
            struct VAR
            {
              inline static constexpr std::size_t NumArgs = 3;
              std::string GroupID;
              std::string Type; // e.g. int, std::uint32_t etc.
              std::string Value;
            };

            struct STR
            {
              inline static constexpr std::size_t NumArgs = 2;
              std::string GroupID;
              std::string Value;
            };

            template <typename T>
            std::optional<T> ParseArgs(const std::string& ArgsUnparsed)
            {
              std::vector<std::string> Args = Util::String::Split(ArgsUnparsed, ',');
              std::size_t ArgsSize = Args.size();

              if constexpr (std::is_same_v<T, STR>)
              {
                if (ArgsSize != STR::NumArgs)
                {
                  COF_LOG("[!] Expected %d arguments but detected %d when parsing $STR()!", STR::NumArgs, ArgsSize);
                  return std::nullopt;
                }

                return T{ Args[0], Args[1] };
              }
              else if constexpr (std::is_same_v<T, VAR>)
              {
                if (ArgsSize != VAR::NumArgs)
                {
                  COF_LOG("[!] Expected %d arguments but detected %d when parsing $VAR()!", VAR::NumArgs, ArgsSize);
                  return std::nullopt;
                }

                return T{ Args[0], Args[1], Args[2] };
              }
            }
          } // !namespace Args
        } // !namespace CodeFunction
      } // !namespace Section
    } // !namespace Config

    inline void PrintHandler(OffsetFinder* Finder, const std::vector<TFound>& FoundList,
      const std::string& PrintConfigPath, const std::string& OffsetsPath, const std::string& ProfileName)
    {
      auto ParsedPrintConfig = Util::JSON_ParseFile(PrintConfigPath);

      if (!ParsedPrintConfig)
      {
        COF_LOG("[!] Failed to parse print configuration file (%s)!", PrintConfigPath.c_str());
        return;
      }

      JSON PrintConfig = *ParsedPrintConfig;
      std::string OutOffsets;
      std::vector<TFound> PrintList;

      for (const auto& MaybePrint : FoundList)
      {
        // We only wanna handle items that have defined 'Print',
        // everything else will be skipped.
        if (MaybePrint.Match.Print)
        {
          PrintList.push_back(MaybePrint);
        }
      }

      if (PrintConfig.contains("Head") && !PrintConfig.at("Head").is_null())
      {
        const auto& Head = PrintConfig["Head"];
        Config::Head CppHead;

        if (Head.contains("ShowGeneratedByMessage") && !Head.at("ShowGeneratedByMessage").is_null())
        {
          CppHead.ShowGeneratedByMessage = Head.at("ShowGeneratedByMessage").get<bool>();
        }

        if (Head.contains("UserNote") && !Head.at("UserNote").is_null())
        {
          CppHead.UserNote = Head.at("UserNote").get<std::string>();
        }

        if (Head.contains("ShowProfile") && !Head.at("ShowProfile").is_null())
        {
          CppHead.ShowProfile = Head.at("ShowProfile").get<bool>();
        }

        if (Head.contains("ShowBinaryVersion") && !Head.at("ShowBinaryVersion").is_null())
        {
          CppHead.ShowBinaryVersion = Head.at("ShowBinaryVersion").get<bool>();
        }

        if (Head.contains("ShowDateGenerated") && !Head.at("ShowDateGenerated").is_null())
        {
          CppHead.ShowDateGenerated = Head.at("ShowDateGenerated").get<bool>();
        }

        // Add to output string here.
        // I know that we could have done this in the conditionals above and
        // that this looks counter intuitive but the code is already designed
        // like this and it should remain consistent.
        if (CppHead.ShowGeneratedByMessage)
        {
          OutOffsets += "// " + CppHead.GeneratedByMessage + '\n';
        }

        if (!CppHead.UserNote.empty())
        {
          OutOffsets += "// " + CppHead.UserNote + '\n';
        }

        bool AddedGapAlready = false;

        if (CppHead.ShowProfile && !ProfileName.empty())
        {
          if (!AddedGapAlready)
          {
            OutOffsets += '\n';
            AddedGapAlready = true;
          }

          OutOffsets += "// Profile       : " + ProfileName + '\n';
        }

        if (CppHead.ShowBinaryVersion)
        {
          auto FileVersion = Finder->GetAnalyzer().GetFileVersion();

          if (FileVersion)
          {
            if (!AddedGapAlready)
            {
              OutOffsets += '\n';
              AddedGapAlready = true;
            }

            OutOffsets += "// File Version  : " + * FileVersion + '\n';
          }
        }

        if (CppHead.ShowDateGenerated)
        {
          if (!AddedGapAlready)
          {
            OutOffsets += '\n';
            AddedGapAlready = true;
          }

          OutOffsets += "// Date Generated: " + Util::GetCurrentDate() + '\n';
        }
      }

      std::size_t GapBetweenHeadAndBody = 0;

      if (PrintConfig.contains("Gap") && !PrintConfig.at("Gap").is_null()
        && PrintConfig.contains("Head") && !PrintConfig.at("Head").is_null())
      {
        GapBetweenHeadAndBody = PrintConfig.at("Gap").get<std::size_t>();
      }

      if (PrintConfig.contains("Body") && !PrintConfig.at("Body").is_null())
      {
        for (std::size_t I = 0; I < GapBetweenHeadAndBody; ++I)
        {
          OutOffsets += '\n';
        }

        const auto& Body = PrintConfig["Body"];

        if (!Body.contains("Sections") || Body.at("Sections").is_null())
        {
          COF_LOG("[!] No 'Sections' found in body!");
          return;
        }

        const auto& Sections = Body["Sections"];
        std::size_t GapBetweenSections = 0;

        if (Body.contains("Gap") && !Body.at("Gap").is_null())
        {
          GapBetweenSections = Body.at("Gap").get<std::size_t>();
        }

        for (std::size_t S = 0; S < Sections.size(); ++S)
        {
          // Add gap between sections if defined
          if (S != 0)
          {
            for (std::size_t I = 0; I < GapBetweenSections; ++I)
            {
              OutOffsets += '\n';
            }
          }

          const auto& Section = Sections[S];

          if (Section.contains("Header") && !Section.at("Header").is_null())
          {
            const auto& Header = Section["Header"];

            std::string OutHeader;
            std::string Title;

            if (Header.contains("Title") && !Header.at("Title").is_null())
            {
              Title = Header.at("Title").get<std::string>();
            }

            if (Header.contains("Frame") && !Header.at("Frame").is_null())
            {
              JSON Frame = Header["Frame"];

              // CppFrame will be initialized with defaults,
              // so the values assigned to it below are optional
              Config::Section::Header::Frame CppFrame;

              if (Frame.contains("Style") && !Frame.at("Style").is_null())
              {
                std::string Style = Frame.at("Style").get<std::string>();

                if (!Config::Section::Header::FrameStyles.count(Style))
                {
                  COF_LOG("[!] Invalid 'FrameStyle' specified (%s)!", Style.c_str());

                  // We could continue parsing and just use defaults when
                  // an invalid style is provided, but for sake of
                  // ease of impl lets just be strict and return.
                  return;
                }

                CppFrame.Style = Config::Section::Header::FrameStyles[Style];
              }

              if (Frame.contains("AlignContent") && !Frame.at("AlignContent").is_null())
              {
                std::string AlignContent = Frame.at("AlignContent").get<std::string>();;

                if (!Config::Section::Header::FrameContentAlignments.count(AlignContent))
                {
                  COF_LOG("[!] Invalid 'FrameContentAlignment' specified (%s)!", AlignContent.c_str());
                  return;
                }

                CppFrame.AlignContent = Config::Section::Header::FrameContentAlignments[AlignContent];
              }

              if (Frame.contains("BorderChar") && !Frame.at("BorderChar").is_null())
              {
                CppFrame.BorderChar = Frame.at("BorderChar").get<std::string>()[0];
              }

              if (Frame.contains("BackgroundChar") && !Frame.at("BackgroundChar").is_null())
              {
                CppFrame.BackgroundChar = Frame.at("BackgroundChar").get<std::string>()[0];
              }

              if (Frame.contains("BorderWidth") && !Frame.at("BorderWidth").is_null())
              {
                CppFrame.BorderWidth = Frame.at("BorderWidth").get<std::size_t>();

                if (CppFrame.BorderWidth % 2)
                {
                  // Too lazy to deal with with additional length calculations
                  // for alignment because the border width is an odd number.
                  // Just enforce divisibility by 2 instead.
                  COF_LOG("[!] 'BorderWidth' (%d) is not divisible by 2!", CppFrame.BorderWidth);
                  return;
                }
              }

              if (Frame.contains("Padding") && !Frame.at("Padding").is_null())
              {
                CppFrame.Padding = Frame.at("Padding").get<std::size_t>();
              }

              // Finally build the header string

              auto MakeComment = [&]()
              {
                OutHeader += "// ";
              };

              auto AddPadding = [&]()
              {
                for (std::size_t I = 0; I < CppFrame.Padding; ++I)
                {
                  MakeComment();

                  if (CppFrame.BackgroundChar)
                  {
                    // Fill background if defined
                    for (std::size_t I = 0; I < CppFrame.BorderWidth; ++I)
                    {
                      OutHeader += *CppFrame.BackgroundChar;
                    }
                  }

                  OutHeader += '\n';
                }
              };

              auto AddBorder = [&](bool Upper /* true for upper border */)
              {
                MakeComment();

                for (std::size_t I = 0; I < CppFrame.BorderWidth; ++I)
                {
                  OutHeader += CppFrame.BorderChar;
                }

                if (Upper)
                {
                  OutHeader += '\n';
                }
              };
              
              // Helper to avoid repeating code
              auto CreateBody = [&]()
              {
                MakeComment();

                // Content its alignment (Title only for now)
                if (CppFrame.AlignContent == Config::Section::Header::FrameContentAlignment::Left)
                {
                  OutHeader += Title;

                  if (CppFrame.BackgroundChar)
                  {
                    for (std::size_t I = 0; I < CppFrame.BorderWidth - Title.size(); ++I)
                    {
                      OutHeader += *CppFrame.BackgroundChar;
                    }
                  }
                }
                else if (CppFrame.AlignContent == Config::Section::Header::FrameContentAlignment::Center)
                {
                  std::size_t TitleSize = Title.size();
                  std::size_t TitleSizeHalf = static_cast<std::size_t>(std::ceil(TitleSize / 2.0));
                  std::size_t BorderWidthHalf = (CppFrame.BorderWidth / 2);
                  std::size_t RemainWidth = TitleSize % 2;

                  std::size_t LeftSideWidth = BorderWidthHalf - TitleSizeHalf;
                  std::size_t RightSizeWidth = LeftSideWidth + RemainWidth;

                  // Insert left side filling
                  for (std::size_t I = 0; I < LeftSideWidth; ++I)
                  {
                    if (CppFrame.BackgroundChar)
                    {
                      OutHeader += *CppFrame.BackgroundChar;
                    }
                    else
                    {
                      // Space if BackgroundChar not defined
                      OutHeader += ' ';
                    }
                  }

                  OutHeader += Title;

                  // Insert right side filling
                  for (std::size_t I = 0; I < RightSizeWidth; ++I)
                  {
                    if (CppFrame.BackgroundChar)
                    {
                      OutHeader += *CppFrame.BackgroundChar;
                    }
                  }
                }
                else if (CppFrame.AlignContent == Config::Section::Header::FrameContentAlignment::Right)
                {
                  for (std::size_t I = 0; I < CppFrame.BorderWidth - Title.size(); ++I)
                  {
                    if (CppFrame.BackgroundChar)
                    {
                      OutHeader += *CppFrame.BackgroundChar;
                    }
                    else
                    {
                      // Space if BackgroundChar not defined
                      OutHeader += ' ';
                    }
                  }

                  OutHeader += Title;
                }

                OutHeader += '\n';
              };

              if (CppFrame.Style == Config::Section::Header::FrameStyle::Borderless)
              {
                AddPadding();
                CreateBody();
                AddPadding();
              }
              else if (CppFrame.Style == Config::Section::Header::FrameStyle::BorderBox)
              {
                AddBorder(true);
                AddPadding();
                CreateBody();
                AddPadding();
                AddBorder(false);
              }
              else if (CppFrame.Style == Config::Section::Header::FrameStyle::BorderUp)
              {
                AddBorder(true);
                AddPadding();
                CreateBody();
                AddPadding();
              }
              else if (CppFrame.Style == Config::Section::Header::FrameStyle::BorderDown)
              {
                AddPadding();
                CreateBody();
                AddPadding();
                AddBorder(false);
              }
            }
            else
            {
              // Frame is not defined or null.
              // We must still add the Title if nothing else.
              OutOffsets += Title;
            }

            OutOffsets += OutHeader + '\n';
          }

          std::size_t GapBetweenHeaderAndCode = 0;

          if (Section.contains("Gap") && !Section.at("Gap").is_null())
          {
            GapBetweenHeaderAndCode = Section.at("Gap").get<std::size_t>();
          }

          // Here comes some of the laziest and ugliest code of all time.
          // TODO: Make readable. Get rid of this disgusting nesting
          if (Section.contains("Code") && !Section.at("Code").is_null())
          {
            // Add gap between header and code if defined
            for (std::size_t I = 0; I < GapBetweenHeaderAndCode; ++I)
            {
              OutOffsets += '\n';
            }

            const auto& Code = Section["Code"];

            for (const auto& CodeLine : Code)
            {
              std::string Line = CodeLine.get<std::string>();

              // State trackers
              bool LastCharWasIndent = false;
              bool ParsingCodeFuncName = false;
              bool ParsingCodeFuncArgs = false;
              bool RegularLine = true;

              std::size_t Indentation = 0;
              std::string CodeFuncName;
              std::string CodeFuncArgs;

              // Code functions (CodeFunc) are our very basic custom functions
              // that we can 'call' in our print config to perform macroish replacements.
              // Once encountered, code functions are parsed and appropriate
              // action is taken based on the code functions 'definition'.
              // Examples of code functions: $VAR(,,) and $STRING().

              // Loop through each char in Line to detect code functions
              // so we can parse them and take appropriate action.
              for (std::size_t I = 0; I < Line.size(); ++I)
              {
                std::size_t NextIndex = I + 1;

                // We dont want to exceed the size boundaries
                // when checking the next element.
                if (NextIndex >= Line.size())
                {
                  break;
                }

                // If Line starts with space/tab, count it as indentation.
                // When the streak of spaces/tabs come to an end, stops counting gracefully.
                if ((I == 0 || LastCharWasIndent) && (Line[I] == ' ' || Line[I] == '\t'))
                {
                  ++Indentation;
                  LastCharWasIndent = true;
                }
                else
                {
                  LastCharWasIndent = false;
                }

                // For simplicity, lines that 'call' print-functions
                // must not contain anything else.
                // TODO: Maybe enforce it?
                if (Line[I] == '$')
                {
                  ParsingCodeFuncName = true;
                  RegularLine = false;
                }
                else if (ParsingCodeFuncName && Line[I] != '(')
                {
                  CodeFuncName += Line[I];
                }
                else if (ParsingCodeFuncName && Line[I] == '(')
                {
                  ParsingCodeFuncName = false;
                  ParsingCodeFuncArgs = true;
                }
                else if (ParsingCodeFuncArgs && Line[I] != ')')
                {
                  CodeFuncArgs += Line[I];
                }
                else if (ParsingCodeFuncArgs && Line[I] == ')')
                {
                  ParsingCodeFuncArgs = false;
                }
              }

              if (RegularLine)
              {
                OutOffsets += Line + '\n';
              }
              else if (!RegularLine && !CodeFuncName.empty() && !CodeFuncArgs.empty())
              {
                if (!Config::Section::CodeFunction::IDs.count(CodeFuncName))
                {
                  COF_LOG("[!] Invalid code function: %s", CodeFuncName.c_str());
                  return;
                }

                const auto& FuncID = Config::Section::CodeFunction::IDs[CodeFuncName];

                if (FuncID == Config::Section::CodeFunction::ID::VAR)
                {
                  auto Args = Config::Section::CodeFunction::Args::ParseArgs<Config::Section::CodeFunction::Args::VAR>(CodeFuncArgs);

                  if (!Args)
                  {
                    COF_LOG("[!] Failed to parse arguments of code function (VAR): %s", CodeFuncArgs.c_str());
                    return;
                  }

                  std::string& GroupID = Args->GroupID;
                  std::vector<TFound> PartOfGroup;

                  for (const auto& ToPrint : PrintList)
                  {
                    const auto& Match = ToPrint.Match;

                    if (Match.Print->Group.ID == GroupID)
                    {
                      // Only add items that are apart of the current group to the list
                      PartOfGroup.push_back(ToPrint);
                    }
                  }

                  // Preserve order non-indexed and duplicate-indexed search items
                  std::stable_sort(PartOfGroup.begin(), PartOfGroup.end(), [](auto& A, auto& B)
                  {
                    return A.Match.Print->Group.Index < B.Match.Print->Group.Index;
                  });

                  for (const auto& ToPrint : PartOfGroup)
                  {
                    const auto& Match = ToPrint.Match;

                    // Some peprocessing here:
                    // Serialize indentation from num to actual chars
                    std::string IndentString;

                    for (std::size_t I = 0; I < Indentation; ++I)
                    {
                      IndentString += ' ';
                    }

                    // Construct format string according to VAR definition
                    std::string IndentAndType = IndentString + Args->Type;
                    std::string NameAndValue = "%s = ";
                    NameAndValue += Args->Value + ";";

                    std::string PreFormat = IndentAndType + ' ' + NameAndValue;

                    // Eventual output for this line:
                    // <Indentation> <Type> <VarName> = <Value>;

                    if (Match.SearchType == SearchType::Immediate)
                    {
                      // All immediate values extracted with DumpAnalyzer are 64-bit
                      auto Value = std::any_cast<std::uint64_t>(ToPrint.Value);
                      OutOffsets += Util::String::Format(PreFormat.c_str(), Match.Print->Name.c_str(), Value) + '\n';
                    }
                    else if (Match.SearchType == SearchType::Displacement)
                    {
                      // Displacements are always 32-bit in our DumpAnalyzer.
                      // This follows the 64-bit displacement standard in Intel assembly.
                      auto Value = std::any_cast<std::uint32_t>(ToPrint.Value);
                      OutOffsets += Util::String::Format(PreFormat.c_str(), Match.Print->Name.c_str(), Value) + '\n';
                    }
                    else if (Match.SearchType == SearchType::Reference)
                    {
                      // All RIP-relative values extracted with DumpAnalyzer are 64-bit
                      auto Value = std::any_cast<std::uint64_t>(ToPrint.Value);
                      OutOffsets += Util::String::Format(PreFormat.c_str(), Match.Print->Name.c_str(), Value) + '\n';
                    }
                  }
                }
                else if (FuncID == Config::Section::CodeFunction::ID::STR)
                {
                  auto Args = Config::Section::CodeFunction::Args::ParseArgs<Config::Section::CodeFunction::Args::STR>(CodeFuncArgs);

                  if (!Args)
                  {
                    COF_LOG("[!] Failed to parse arguments of code function (STR): %s", CodeFuncArgs.c_str());
                    return;
                  }

                  std::string& GroupID = Args->GroupID;
                  std::vector<TFound> PartOfGroup;

                  for (const auto& ToPrint : PrintList)
                  {
                    const auto& Match = ToPrint.Match;

                    if (Match.Print->Group.ID == GroupID)
                    {
                      // Only add items that are apart of the current group to the list
                      PartOfGroup.push_back(ToPrint);
                    }
                  }

                  // Preserve order of non-indexed and duplicate-indexed search items
                  std::stable_sort(PartOfGroup.begin(), PartOfGroup.end(), [](auto& A, auto& B)
                  {
                    return A.Match.Print->Group.Index < B.Match.Print->Group.Index;
                  });

                  for (const auto& ToPrint : PartOfGroup)
                  {
                    const auto& Match = ToPrint.Match;

                    // Some peprocessing here:
                    // Serialize indentation from num to actual chars
                    std::string IndentString;

                    for (std::size_t I = 0; I < Indentation; ++I)
                    {
                      IndentString += ' ';
                    }

                    // Pre-formatted raw value, e.g. %llX, %d etc.
                    std::string PreFormat = Args->Value;

                    // Eventual output for each line of the string value:
                    // <Indentation> <LineOfValue>

                    // STR Value could be a multi-line string unlike VAR,
                    // so we must remember to add indentation to each line.

                    if (Match.SearchType == SearchType::Immediate)
                    {
                      // All immediate values extracted with DumpAnalyzer are 64-bit
                      auto Value = std::any_cast<std::uint64_t>(ToPrint.Value);
                      OutOffsets += IndentString + Util::String::Format(PreFormat.c_str(), Value) + '\n';
                    }
                    else if (Match.SearchType == SearchType::Displacement)
                    {
                      // Displacements are always 32-bit in our DumpAnalyzer.
                      // This follows the 64-bit displacement standard in Intel assembly.
                      auto Value = std::any_cast<std::uint32_t>(ToPrint.Value);
                      OutOffsets += IndentString + Util::String::Format(PreFormat.c_str(), Value) + '\n';
                    }
                    else if (Match.SearchType == SearchType::Reference)
                    {
                      // All RIP-relative values extracted with DumpAnalyzer are 64-bit
                      auto Value = std::any_cast<std::uint64_t>(ToPrint.Value);
                      OutOffsets += IndentString + Util::String::Format(PreFormat.c_str(), Value) + '\n';
                    }
                    else if (Match.SearchType == SearchType::TslDecryptor32)
                    {
                      auto Value = std::any_cast<DumpAnalyzer::TslDecryption<std::uint32_t>>(ToPrint.Value);
                      auto Tokens = Util::String::Split(Value.Pseudo.ToCode(Match.Print->Name), '\n');

                      // TslDecryptor32 value is multi-line,
                      // add indentation to each line.
                      for (auto& Token : Tokens)
                      {
                        Token = IndentString + Token;
                      }

                      std::string IndentedValue = Util::String::Join(Tokens, '\n');
                      OutOffsets += Util::String::Format(PreFormat.c_str(), IndentedValue) + '\n';
                    }
                    else if (Match.SearchType == SearchType::TslDecryptor64)
                    {
                      auto Value = std::any_cast<DumpAnalyzer::TslDecryption<std::uint64_t>>(ToPrint.Value);
                      auto Tokens = Util::String::Split(Value.Pseudo.ToCode(Match.Print->Name), '\n');

                      // TslDecryptor64 value is multi-line,
                      // add indentation to each line.
                      for (auto& Token : Tokens)
                      {
                        Token = IndentString + Token;
                      }

                      std::string IndentedValue = Util::String::Join(Tokens, '\n');
                      OutOffsets += Util::String::Format(PreFormat.c_str(), IndentedValue) + '\n';
                    }
                  }
                }
              }
            }
          }
        }
      }

      std::ofstream OutOffsetsFile(OffsetsPath);

      if (!OutOffsetsFile)
      {
        COF_LOG("[!] Failed to open (%s) for printing!", OffsetsPath.c_str());
        return;
      }

      OutOffsetsFile << OutOffsets;
      COF_LOG("[+] Successfully printed found offsets to: %s", OffsetsPath.c_str());
    }
  } // !namespace Printer
}  // !namespace COF

#endif // !COF_PRINTER