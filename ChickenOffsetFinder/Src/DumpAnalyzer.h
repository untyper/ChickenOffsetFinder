#ifndef COF_DUMP_ANALYZER_H
#define COF_DUMP_ANALYZER_H

#include "MemoryDumper.h"
#include "Util.h"
#include "CodeGeneration.h"

//#include <Windows.h>
#include <Zydis/Zydis.h>

#include <fstream>
#include <vector>
#include <string>
#include <optional>
#include <variant>
#include <utility>
#include <set>
#include <cstdint>
#include <cstddef>
#include <functional>
#include <sstream>
#include <unordered_map>

namespace COF
{
#ifndef COF_MODE
#define COF_MODE
  enum class Mode
  {
    Regions, // Analyzes memory dump whose memory was dumped region by region (VAD tracked)
    Sparse   // Analyzes memory dump that is exactly as it was in memory (unused space included)
  };
#endif

  class DumpAnalyzer
  {
  private:
    struct Metadata : public MemoryDumper::Metadata
    {
      struct BaseAddressInformation
      {
        pmm::Region Region;
        std::uint64_t RegionOffset = 0;
      } BaseAddressInfo;

      // For convenience
      std::uint64_t DumpSectionOffset = 0;

      Metadata& operator=(const MemoryDumper::Metadata& Base);
      Metadata(const MemoryDumper::Metadata& Base);
      Metadata() = default;
    };

  public:
    class PeSection
    {
      std::string Name;
      std::uint64_t Offset;
      std::size_t Size;

    protected:
      PeSection(const std::string& Name, std::uint64_t Offset, std::uint64_t Size);

    public:
      const std::string& GetName() const;
      std::uint64_t GetOffset() const;
      std::size_t GetSize() const;

      PeSection() = default;

      friend class DumpAnalyzer;
    };

    // Alias because they're practically the same
    using PeHeader = PeSection;

    class PeSections
    {
      std::vector<PeSection> Sections_;

    protected:
      PeSections(const std::vector<PeSection>& Sections);

    public:
      const std::vector<PeSection>& GetAll() const;
      std::optional<PeSection> GetSection(const std::string& Name) const;

      PeSections() = default;

      friend class DumpAnalyzer;
    };

    enum class StringType
    {
      ASCII,
      UTF16_LE
    };

    // Structure to hold the extracted pseudocode parameters.
    template <typename XorT = std::uint64_t>
    struct TslDecryption
    {
      struct Pseudocode
      {
        std::string Code; // Pseudocode (function) generated by following the instruction chain

        // Turns pseudocode into valid code by giving the identifiers names.
        // TODO: Customize indentation through argument
        std::string& ToCode(
          const std::string& FunctionName = "Decryptor",
          const std::string& ParamName = "Value",
          const std::string& VarPrefix = "V")
        {
          Util::String::ReplaceAll(this->Code, CodeGeneration::FunctionName, FunctionName);
          Util::String::ReplaceAll(this->Code, CodeGeneration::ParamName, ParamName);
          Util::String::ReplaceAll(this->Code, CodeGeneration::VarPrefix, VarPrefix);
          return this->Code;
        }
      } Pseudo;

      bool IsX32 = false;         // true if ROR4, false if ROR8
      bool IsRotateRight = false; // true if ROR, false if ROL
      bool IsShiftRight = false;  // true for SHR, false for SHL
      XorT Xor1 = 0;              // Value from first XOR instruction
      XorT Xor2 = 0;              // Value from third XOR instruction
      std::uint8_t Rotate = 0;    // Immediate value for rotation
      std::uint8_t Shift = 0;     // Immediate value for shift

      std::string ToString() const
      {
        std::ostringstream OutStream;

        OutStream
          << "{ IsX32: " << (this->IsX32 ? "true" : "false")
          << ", IsRotateRight: " << (this->IsRotateRight ? "true" : "false")
          << ", IsShiftRight: " << (this->IsShiftRight ? "true" : "false")
          << ", Xor1: 0x" << std::hex << std::uppercase << this->Xor1
          << ", Xor2: 0x" << std::hex << std::uppercase << this->Xor2 << std::dec
          << ", Rotate: " << static_cast<int>(this->Rotate)
          << ", Shift: " << static_cast<int>(this->Shift) << "}";

        return OutStream.str();
      }
    };

    struct MemoryOperand
    {
      std::optional<ZydisRegister> Base;
      std::optional<ZydisRegister> Index;
      std::optional<std::uint8_t> Scale;
      std::optional<std::int64_t> Disp;
    };

    struct MatchOperand
    {
      std::optional<MemoryOperand> Mem;
      std::optional<ZydisRegister> Reg;
      std::optional<std::uint64_t> Imm;
    };

    struct MatchInstruction
    {
      std::optional<ZydisMnemonic> Mnemonic;
      std::vector<std::optional<MatchOperand>> Operands;
    };

    struct MatchRange
    {
      std::uint64_t Offset = 0;
      std::size_t Size = 0;
    };

    // This will be returned by every scan/find instruction
    template <typename T = std::monostate>
    struct Result
    {
      // Offset & size about where our value was found,
      // useful for debugging etc.
      MatchRange Range;

      // Not all calls return a value.
      // Check if Value is truthy/falsy to know
      // if a value is available.
      std::optional<T> Value;
    };

    using PatternElem = std::pair<std::uint8_t /*Mask*/, std::uint8_t /*Value*/>;

  private:
    // A simple register tracker.
    template <typename T = std::uint64_t>
    struct RegisterTracker
    {
      std::unordered_map<ZydisRegister, T> Values;

      // Track "mov reg, imm"
      void Store(ZydisRegister Reg, T Val)
      {
        Values[Reg] = Val;
      }

      // Propagate constant from src register to dst register.
      void Propagate(ZydisRegister Dst, ZydisRegister Src)
      {
        auto It = Values.find(Src);

        if (It != Values.end())
        {
          Values[Dst] = It->second;
        }
      }

      std::optional<T> Get(ZydisRegister Reg) const
      {
        auto It = Values.find(Reg);

        if (It != Values.end())
        {
          return It->second;
        }

        return std::nullopt;
      }

      std::optional<T> ResolveOperand(const ZydisDecodedOperand& Operand) const
      {
        if (Operand.type == ZYDIS_OPERAND_TYPE_IMMEDIATE)
        {
          return static_cast<T>(Operand.imm.value.u);
        }
        else if (Operand.type == ZYDIS_OPERAND_TYPE_REGISTER)
        {
          return this->Get(Operand.reg.value);
        }

        return std::nullopt;
      }
    };

    Mode AnalysisMode = Mode::Regions;
    mutable std::ifstream InFile;
    std::string InFilePath;
    Metadata InMetadata;
    std::vector<pmm::Region> InMemoryRegions;
    std::optional <std::string> InFileVersion;
    std::optional<PeHeader> InPeHeader;
    std::optional<PeSections> InPeSections;
    std::set<std::uint64_t> InFunctionOffsets;

    ZydisDecoder Decoder;
    ZydisMachineMode MachineMode = ZYDIS_MACHINE_MODE_LONG_64;
    ZydisStackWidth StackWidth = ZYDIS_STACK_WIDTH_64;

    std::optional<std::uint64_t> TranslateVirtualOffsetToFileOffset(std::uint64_t VirtualOffset) const;
    std::vector<std::uint8_t> _Read(std::uint64_t Offset, std::size_t Size) const;
    std::vector<std::uint8_t> Read(std::uint64_t Offset, std::size_t Size) const;

    template <typename T>
    T _Read(std::uint64_t Offset) const
    {
      T Result{};
      this->InFile.clear();
      this->InFile.seekg(Offset, std::ios::beg);
      this->InFile.read(reinterpret_cast<char*>(&Result), sizeof(T));
      return Result;
    }

    template <typename T>
    T Read(std::uint64_t Offset) const
    {
      if (this->AnalysisMode == Mode::Regions)
      {
        auto FileOffset = this->TranslateVirtualOffsetToFileOffset(Offset);

        if (FileOffset)
        {
          return this->_Read<T>(*FileOffset);
        }

        return T{};
      }
      else if (this->AnalysisMode == Mode::Sparse)
      {
        return this->_Read<T>(Offset);
      }

      return T{};
    }

    std::optional<std::string> GetFileVersionInternal() const;

    void ExtractAndSavePeHeaderAndSections();
    void ExtractAndSaveFunctions();
    void ExtractAndSaveFileVersion();

    std::vector<PatternElem> ParsePattern(const std::string& PatternStr) const;
    std::optional<std::uint64_t> FindPattern(const std::vector<uint8_t>& Buffer, const std::vector<PatternElem>& Pattern) const;

  public:
    const std::vector<pmm::Region>& GetMemoryRegions() const;
    const std::optional<std::string>& GetFileVersion() const;
    const std::optional<PeHeader>& GetPeHeader() const;
    const std::optional<PeSections>& GetPeSections() const;
    const std::set<std::uint64_t>& GetFunctions() const;

    template<StringType T = StringType::UTF16_LE>
    std::optional<Result<std::vector<std::uint64_t>>> FindString(const std::string& Str, std::size_t MaxMatches = 1) const;

    std::optional<Result<>> FindPattern(std::uint64_t StartOffset, std::size_t Size, const std::string& IdaPattern) const;
    std::optional<Result<std::vector<MatchRange>>> FindPatternSubsequence(std::uint64_t StartOffset, std::size_t Size, const std::vector<std::string>& IdaPatterns) const;
    
    std::optional<Result<std::vector<MatchRange>>> FindInstructionSequence(std::uint64_t StartOffset, std::size_t Size, const std::vector<MatchInstruction>& Pattern) const;
    std::optional<Result<std::vector<MatchRange>>> FindInstructionSubsequence(std::uint64_t StartOffset, std::size_t Size, const std::vector<MatchInstruction>& Pattern) const;

    std::optional<Result<std::uint64_t>> ResolveRipRelativeOffset(std::uint64_t StartOffset, std::size_t Size,
      std::function<bool(ZydisDecodedInstruction*, ZydisDecodedOperand*)> Filter = nullptr) const;
    std::optional<Result<std::uint64_t>> FindRipRelativeReference(std::uint64_t StartOffset, std::size_t Size, std::uint64_t TargetDataOffset,
      std::function<bool(ZydisDecodedInstruction*, ZydisDecodedOperand*)> Filter = nullptr) const;

    std::optional<Result<std::uint32_t>> ExtractDisplacement(std::uint64_t StartOffset, std::size_t Size) const;
    std::optional<Result<std::uint64_t>> ExtractImmediate(std::uint64_t StartOffset, std::size_t Size) const;

    template <typename XorT = std::uint64_t>
    std::optional<Result<std::vector<TslDecryption<XorT>>>> ExtractTslDecryptors(std::uint64_t StartOffset, std::size_t Size = 512) const;

    template <Mode M = Mode::Regions>
    bool Analyze();
    bool Open(const std::string& FilePath);

    DumpAnalyzer(const std::string& FilePath);
    DumpAnalyzer& operator=(const DumpAnalyzer& Other);
    DumpAnalyzer(const DumpAnalyzer& Other);
    DumpAnalyzer() = default;
    ~DumpAnalyzer();
  };
}

#endif // !COF_DUMP_ANALYZER_H
